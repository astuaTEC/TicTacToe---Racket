#lang racket
;--------------------------------------------------------INICIO DEL JUEGO----------------------------------------------------------------------
#|
Funcion de inicio del juego. Recibe como parametros la cantidad de filas y de columnas que tendra la matriz a crear.
Se realizan las validaciones necesarias para verificar que tanto n como m esten entre 3 y 10, dimensiones minimas y maximas
que puede tener el tablero de tik tak toe. En caso de cumplir con una de las dimensiones permitidas, se procede a crear la matriz.
|#
(define (TTT n m)
  (printf "Se va a crear una matriz de ~v por ~v" n m)
  (display "\n")
  (if (> n 10)
      (display "La cantidad de filas debe ser menor o igual a 10 \n")
      (if (< n 3)
          (display "La cantidad de filas debe ser mayor o igual a 3 \n")
          (if (> m 10)
              (display "La cantidad de columnas debe ser menor o igual a \n")
              (if (< m 3)
                  (display "La cantidad de columnas debe ser mayor o igual a 3 \n")
                  (crearMatriz n m '())
              )
          )
       )
   )               
)
;-------------------------------------------------------CREACION DE LA MATRIZ------------------------------------------------------------------
#|
Funcion que se encarga de la creacion de la estructura de la matriz. De manera recursiva, por cada m especificado por el usuario al
inicializar el programa, se le agrega a la estructura una nueva fila de dimension n. Al tener la matriz creada, de las dimensiones correctas,
se inicia el ciclo de juego, siempre con el usuario colocando la primera ficha.
|#
(define (crearMatriz nContador mContador matriz)
  (if (> mContador 0)
      (crearMatriz nContador (- mContador 1) (append matriz (list(crearFila nContador '()))))
      (cicloDeJuego matriz 1)
  )
)
#|
Funcion de creacion de filas. Funciona como auxiliar de la funcion anterior, que crea la matriz. Es llamada por cada m de las dimensiones de la
matriz, y de manera recursiva agrega 0 (el valor que indica que el tablero esta vacio) por cada n de las dimensiones de la matriz. Esto quiere
decir que se agregan n casillas m veces dentro de la matriz.
|#
(define (crearFila nContador filaCrear)
  (if (> nContador 0)
      (crearFila (- nContador 1) (append filaCrear '(0)))
      filaCrear
   )  
)     
;--------------------------------------------------------CICLO DEL JUEGO-----------------------------------------------------------------------
#|
Funcion que se encarga de seguir el flujo del juego. Recibe como parametros la matriz previamente creada, ademas del jugador actual que esta
colocando la ficha en ese turno. Por defecto, el usuario siempre inicia la partida. Se ha definido al usuario como jugadorActual 1 y a la
maquina como jugadorActual 2.

Primero, se revisa, por medio de la funcion hayGanador, si el jugador actual ha colocado la ficha que, segun los criterios y las reglas de la
partida, le permita declararse ganador de la misma.

En caso de no existir ganador, el cicloDeJuego, por medio del parametro jugadorActual, decide si el usuario o la maquina debe ser el que
coloque una ficha en el turno (o iteracion recursiva) actual.

Si es el usuario el que debe colocar una ficha, se llama al cicloDeJuego con una matriz actualizada proveniente de ejecutarMovimientoJugador,
y se cambia el jugador actual a 2.

Si es la maquina la que debe colocar una ficha, se llama al cicloDeJuego con una matriz actualizada proveniente de ejecutarAlgoritmoVoraz,
y se cambia el jugador actual a 1.
|#
(define (cicloDeJuego matriz jugadorActual)
  (if (equal? (hayGanador matriz '() '() jugadorActual)  #t)
      (print "Fin del juego")
      (if (= jugadorActual 1)
          (cicloDeJuego (ejecutarMovimientoJugador matriz (string->number (read-line)) (string->number (read-line)) (length matriz) (length (car matriz)))        
                        2
          ) 
          (cicloDeJuego (cadr (colocarFichaMaquina matriz 2))
                        1
          )
      )
  )     
)
;-----------------------------------------------------TURNO DEL JUGADOR-----------------------------------------------------------------------
#|
Funcion que se encarga de ejecutar el movimiento seleccionado por el usuario. Recibe como parametros la matriz, la columna y la fila donde se
quiere colocar la ficha, ademas de las dimensiones maximas de la matriz de juego.


Primero se valida que las posiciones m n donde se quiere colocar la ficha no sobrepasen a las dimensiones maximas de la matriz. En caso de ser
asi, se llama a la funcion notificarError con un codigo de error 1 o 2, correspondiente a si es la posicion m o n la que causa el error.

Luego, se valida que la posicion m n donde se quiere colocar la ficha no este ocupada, y en caso de estarla se llama a la funcion
notificarError con el codigo de error 3.

En caso de que la posicion m n corresponda a una de las posibles dimensiones, se llama a la funcion colocarFichaJugador.
|#
(define (ejecutarMovimientoJugador matriz mPosicion nPosicion mMaximo nMaximo)
  (if (> mPosicion mMaximo)
     (notificarError 1 matriz mMaximo nMaximo)
      (if (> nPosicion nMaximo)
          (notificarError 2 matriz mMaximo nMaximo)          
          (if (= (encontrarFichaPorPosicion matriz mPosicion nPosicion '()) 0)
              (colocarFichaJugador mPosicion nPosicion 1 mMaximo matriz '() 1)
              (notificarError 3 matriz mMaximo nMaximo)
          )
     )
  )
)
#|
Funcion que coloca la ficha del jugador. Recibe como parametros la posicion m, la posicion n, un contador que siempre inicia en 1, y que
facilita el recorrido por las columnas de la matriz, la cantidad total de columnas m, la matriz a la que se le quiere agregar la ficha, la
nueva matriz que se va formando de la antigua y el elemento que se quiere colocar, en este caso un 1 (que corresponde a la ficha definida
para el usuario).

Primero, se verifica si la posicion m (donde el usuario quiere colocar la ficha) corresponde al valor actual del contador. De ser asi, se sabe
que la llamada recursiva actual es la que corresponde a la posicion de columna correcta dentro de la matriz, por lo que solo faltaria colocar
la ficha en esa columna numero contador, en la posicion deseada nPosicion.
Para esto se llama recursivamente a la funcion colocarFichaJugador (para que siga reconstruyendo la nueva matriz) pero aplicandole un cdr a la
matriz y haciendole un append a la nueva matriz de la lista proveniente de la funcion auxiliar colocarFichaEnFila. Esta es la forma de ir
actualizando la matriz al colocar una ficha. Se va "recortando" la matriz antigua con cdr y se van agregando las columnas con la ficha en
su posicion n correspondiente.

En caso de que la posicion indicada mPosicion no sea igual a contador, quiere decir que la llamada recursiva actual no es la que se encuentra
sobre la columna deseada, por lo que se omite la modificacion de columna y se vuelve a llamar a si misma, aumentando el contador por 1,
haciendole un cdr a la matriz, y agregandole a la nueva matriz la columna actual proveniente de car matriz.

Es importante mencionar que la condicion de parada de esta llamada recursiva es cuando el contador sea mayor que el mTotal (la
cantidad de columnas de la matriz), momento en el cual se ha recorrido, reconstruido y actualizado toda la matriz nueva a partir de la matriz
original, y procede a llamarse a la funcion  actualizarMatriz.
|#
(define (colocarFichaJugador mPosicion nPosicion contador mTotal matriz matrizNueva elemento)
  (display "Colocando en ")
  (display mPosicion)
  (display " " )
  (display nPosicion)
  (display "\n")
  (if (= mPosicion contador)
      (colocarFichaJugador mPosicion
                           nPosicion
                           (+ contador 1)
                           mTotal
                           (cdr matriz)
                           (append matrizNueva (list(colocarFichaEnFila nPosicion 1 (length (car matriz)) (car matriz) '() elemento)))
                           elemento
      )
      (if (>= mPosicion contador)
          (colocarFichaJugador mPosicion
                               nPosicion
                               (+ contador 1)
                               mTotal
                               (cdr matriz)
                               (append matrizNueva (list(car matriz)))
                               elemento
          )
          (if (<= contador mTotal)
              (colocarFichaJugador mPosicion
                                   nPosicion
                                   (+ contador 1)
                                   mTotal
                                   (cdr matriz)
                                   (append matrizNueva (list(car matriz)))
                                   elemento
              )
              (actualizarMatriz matrizNueva)   
          )
      )
  )   
)
#|
Funcion auxiliar que se encarga de colocar las fichas en la columna especifica, encontrada a partir de la funcion anterior. Recibe como
parametros a la posicion dentro de la fila a donde se quiere colocar la ficha, un contador que facilite el recorrido dentro de la fila,
la dimension total de la fila, la fila original, la nueva fila que se actualiza al agregar el elemento, y el elemento que se quiere agregar.

Trabaja de forma similar a la funcion anterior, reconstruyendo la nueva fila a partir de la fila anterior de manera recursiva, hasta que el
contador es igual a la posicion n especifica, momento en el cual el valor se cambia por el elemento.

Una vez mas, la condicion de parada es cuando el contador sea mayor que la dimension maxima de la fila nTotal, momento en el cual se sabe
que la fila ya esta correctamente reconstruida, al haberla recorrido en su totalidad. Eh ese momento devuelve a la nueva fila ya actualizada
a la funcion colocarFichaJugador, para que esta siga reconstruyendo la matriz.
|#
(define (colocarFichaEnFila nPosicion contador nTotal fila nuevaFila elemento)
  (if (= nPosicion contador)
      (colocarFichaEnFila nPosicion
                          (+ contador 1)
                          nTotal
                          (cdr fila)
                          (append nuevaFila (list elemento))
                          elemento
      )
      (if (>= nPosicion contador)
          (colocarFichaEnFila nPosicion
                              (+ contador 1)
                              nTotal
                              (cdr fila)
                              (append nuevaFila (list(car fila)))
                              elemento
          )
          (if (<= contador nTotal)
              (colocarFichaEnFila nPosicion
                                  (+ contador 1)
                                  nTotal
                                  (cdr fila)
                                  (append nuevaFila (list(car fila)))
                                  elemento
              )
              nuevaFila
         )
      )
  )
)
#|
Funcion encargada de mostrar al usuario la matriz actualizada en consola, ademas de devolverla al cicloDeJuego para que este pueda seguir
su correcto funcionamiento una vez que el usuario coloca una ficha. Recibe como parametros unicamente a la matriz actualizada.
|#
(define (actualizarMatriz matrizNueva)
  (display matrizNueva)
  (display "\n")
  matrizNueva
)

#|
Funcion encargada de la notificacion y correcion de errores en la colocacion de fichas. Recibe como parametros un codigo de error, la matriz,
y las dimensiones de la misma. En caso de que el usuario coloque un valor de m o n mayor a los permitidos, le sera notificado por medio de
esta funcion. El error de tipo 1 corresponde a una posicion m que excede las dimensiones de la matriz. El error de tipo 2 corresponde a una
posicion n que excede las dimensiones de la matriz. El error de tipo indica que esa posicion m n ya esta ocupada.
En caso de existir errores, se llama a la funcion ejecutarMovimientoJugador, con el fin de que el usuario corrija las posiciones seleccionadas.
|#
(define (notificarError tipo matriz mMaximo nMaximo)
  (if (= tipo 1)
      (display "Se ha colocado una posicion de columna no valida para las dimensiones de la matriz \n")
      (if (= tipo 2)
          (printf "Se ha colocado una posicion de fila no valida para las dimensiones de la matriz \n")
          (printf "Se ha colocado una posicion donde ya existe una ficha en la matriz \n")
      )
  )
  (ejecutarMovimientoJugador matriz (string->number (read-line)) (string->number (read-line)) mMaximo nMaximo)
)                                
;--------------------------------------------------------RECORRER LA MATRIZ--------------------------------------------------------------------
#|
Funcion que encuentra todas las posiciones (m n) donde hayan fichas de tipo 1 (jugador), 2 (maquina) o 0 (espacio vacio). Recibe como
parametros a la matriz, la columna actual, un contador para recorrer las columnas, un contador para recorrer las filas, el elemento que
se busca en la matriz y una lista de tuplas (m n) donde se van almacenando las posiciones donde se encuentre al elemento.

Contrario a la funcion de agregar fichas, esta trabaja sin necesidad de actualizar una nueva matriz, por lo que se puede simplemente ir
"recortandola" a lo largo de la ejecucion recursiva.

Primero, la condicion de parada ocurre si tanto la columna actual mActual como la matriz son nulas (ya no quedan elementos que analizar en
la matriz). En caso de ocurrir esto, se llama a la funcion auxiliar actualizarPosiciones para que notifique al usuario.

En caso de que solo la columna actual mActual sea nula, quiere decir que ya se analizaron todas las posiciones de dicha columna, por lo que se
procede a llamar a la funcion encontrarFichasColocadas con el cdr de la matriz, la nueva columna actual como el car de la matriz, aumentando
el contador de la columna donde se encuentra la funcion, reiniciando el contador de fila nContador a 1 (por cada nueva columna, la fila empieza
a contarse en 1) y conservando tanto el elemento buscado como las posiciones previas encontradas.

En caso de que la columna actual mActual no sea nula, quiere decir que quedan elementos por revisar en la misma. Se hace un condicional para
verificar si el primer elemento de la columna actual mActual es igual al elemento, y de ser asi, se hace una llamada recursiva recortando con
cdr la mActual, aumentando el contador de fila, y agregando a las posiciones la tupla (mContador nContador). Caso contrario, se realiza
lo anteriormente descrito, pero sin agregar nada a las posiciones.
|#
(define (encontrarFichasColocadas matriz mActual mContador nContador elemento posiciones)
  (if (null? mActual)
      (if (null? matriz)
          (actualizarPosiciones posiciones elemento)
          (encontrarFichasColocadas (cdr matriz)
                                    (car matriz)
                                    (+ mContador 1)
                                    1
                                    elemento
                                    posiciones
          )      
      )
      (if (equal? (car mActual) elemento)
          (encontrarFichasColocadas matriz
                                    (cdr mActual)
                                    mContador
                                    (+ nContador 1)
                                    elemento
                                    (append posiciones (list (list mContador nContador)))
          )
                                                                                      
          (encontrarFichasColocadas matriz
                                    (cdr mActual)
                                    mContador
                                    (+ nContador 1)
                                    elemento
                                    posiciones
          )
      )
  )
)
#|
Funcion que encuentra el valor de la ficha de una posicion especifica. Nuevamente, funciona de manera similar al procedure anterior. Recibe
como parametros a la matriz, la posicion m n deseada y la columna actual.

Primero, si la columna actual es nula, quiere decir que en la misma no estaba el elemento, por lo que se procede a la siguiente iteracion, esta
vez con el cdr de la matriz como la matriz, y el car de la matriz como la columna actual.

Si la columna actual no es nula, pero la mPosicion (la posicion que se busca) es mayor que 1, se debe seguir con la siguiente iteracion, porque
esto significa que la posicion mPosicion esta mas adelante en la matriz. Se hace el cdr de la matriz, se le resta 1 a mPosicion y se selecciona
la mActual como el car de la matriz (con el fin de ir avanzando en posiciones de columna)

Ahora, en caso de que la posicion mActual si sea 1, quiere decir que se esta ubicado en la columna correcta, por lo que se repite el proceso,
esta vez con el contador nPosicion, para encontrar el elemento n dentro de la columna m. Nuevamente, se resuelve por medio de llamadas
recursivas que va aplicando un cdr a la mActual, y restandole 1 a la nPosicion.

Una vez que tanto mPosicion como nPosicion son iguales a 1 se puede afirmar que la iteracion se encuentra ubicada "sobre" el elemento deseado,
por lo que se llega a la posicion de parada y se retorna el car de la mActual (que contiene al elemento dentro de la posicion seleccionada).
|#
(define (encontrarFichaPorPosicion matriz mPosicion nPosicion mActual)
  (if (null? mActual)
      (encontrarFichaPorPosicion (cdr matriz) mPosicion nPosicion (car matriz))
      (if (> mPosicion 1)
          (encontrarFichaPorPosicion (cdr matriz) (- mPosicion 1) nPosicion (car matriz))
          (if (> nPosicion 1)
              (encontrarFichaPorPosicion matriz mPosicion (- nPosicion 1) (cdr mActual))
              (car mActual)
          )
     )
  )
)

                                              
                  
                                       
                                 
                        
          
          
          



                                    
#|
Funcion auxiliar utilizada para notificar al usuario de las posiciones donde se encuentran sus fichas y las de la maquina. Recibe como
parametros a la lista de tuplas de las posiciones, ademas del elemento que se busco (puede ser 1 o 2).

En caso de que el elemento sea 1, se notifica refiriendose al jugador. En caso de que el elemento sea 2, se notifica refiriendose
a la maquina. En caso de que el elemento sea 0, notifica en referencia a los espacios vacios dentro de la matriz. Seguidamente
se muestra en consola la lista de posiciones.

Finalmente se retorna la lista de posiciones para el resto de funciones que asi lo requieran.
|#
(define (actualizarPosiciones posiciones elemento)
  (if (= elemento 1)
      (display "El jugador tiene las siguientes fichas en juego ")
      (if (= elemento 2)
          (display "La maquina tiene las siguientes fichas en juego ")
          (display "Los candidatos posibles para colocar son los siguientes ")
      )
  )
  (display posiciones)
  (display "\n")
  posiciones   
)
;--------------------------------------------------------TURNO DE LA MAQUINA-------------------------------------------------------------------
#|
Funcion encargada de colocar la ficha de la maquina. Recibe como parametros la matriz de juego y el elemento que se colocara dentro de la misma,
que es por defecto un 2. Esta funcion tiene la finalidad de ayudar a controlar el flujo de juego, al llamarse de forma recursiva y alternada
con la funcion respectiva del turno del usuario. Basicamente inicializa el algoritmo voraz.
|#
(define (colocarFichaMaquina matriz elemento)
  (display "Ejecutando turno de la maquina \n")
  (ejecutarAlgoritmoVoraz matriz)
)

#|
Funcion encargada de verificar si existe un gane horizontal, ya sea por parte del usuario o de la maquina. Recibe como parametros a las fichas
ya sea del usuario o de la maquina en los parametros llamados fichasMaquina y fichasMaquinaAuxiliar, una de las listas se utiliza para recorrer
la lista (se va recortando) y la otra se utiliza para comparar, por lo que es necesario contar con ambas. Adicionalmente, considerando que la
matriz cuenta con n filas y m columnas, se recibe como parametro este numero m, que sera la cantidad requerida por una linea horizontal para
ser considerada un gane valido. Finalmente, se recibe una ficha para ganar que es una tupla (n m), que se maneja de esta manera para detener
la recursion en el momento que deje de ser nula, es decir, en el momento que se encuentre la primera solucion valida, con la finalidad de
optimizar la ejecucion y no evaluar todas las posiciones si ya se encuentra un gane valido. Recibe tambien la lista de candidatos posibles
para colocar una ficha, con la finalidad de pasarlo a las funciones auxiliares.

Primeramente, valida que la lista de fichas maquina no sea una lista nula. Si es nula, quiere decir que no se encontro una solucion valida
entre todas las fichas colocadas por el usuario o por la maquina, por lo que se retorna un valor nulo por defecto de la ficha para ganar.

En caso de no ser nula, se evalua si la ficha para ganar es nula. En caso de ser nula, quiere decir que no se ha dado con una solucion exitosa
dentro de las posibles lineas horizontales, por lo que se llama de manera recursiva, recortando la lista de fichas auxiliares, y actualizando
la posible ficha para ganar llamando a la funcion fichaParaGanarHorizontal.

En caso de que la ficha para ganar no sea nula, quiere decir que se ha encontrado una solucion horizontal, y se devuelve este valor para que
el programa no tenga que verificar el resto de fichas colocadas por el usuario o por la maquina.
|#
(define (revisarGaneHorizontal fichasMaquina fichasMaquinaAuxiliar mParaGanar fichaParaGanar candidatos)
  (if (null? fichasMaquinaAuxiliar)
      fichaParaGanar

      (if (null? fichaParaGanar)
          (revisarGaneHorizontal fichasMaquina
                                 (cdr fichasMaquinaAuxiliar)
                                 mParaGanar
                                 (fichaParaGanarHorizontal fichasMaquina (car fichasMaquinaAuxiliar) mParaGanar '() candidatos)
                                 candidatos
          )
          fichaParaGanar
      )
  )
)
#|
Funcion que analiza cada una de las fichas colocadas por la maquina o por el usuario, y las compara con la lista de todas las fichas colocadas
por el mismo. Recibe como parametro la lista de fichas colocadas, la ficha especifica a analizar, la cantidad necesaria de fichas en la misma
fila para ganar, y mantiene un parametro recursivo con las posiciones presentes de fichas dentro de una determinada fila n, con la finalidad
de, en caso de faltar solo una ficha dentro de esa fila, cual es la posicion ausente que provocaria el gane de la maquina o del usuario.
Recibe tambien la lista de candidatos posibles para colocar una ficha, con la finalidad de pasarlo a las funciones auxiliares.

Primeramente, se valida como condicion de parada de la recursividad que la lista de fichas colocadas sea nula. En caso de ser nula, quiere
decir que ya se analizaron todas las posibles fichas en comparacion de la fichaAnalizar, por lo que la cantidad de fichas presentes en una
determinada fila n debe estar a una unidad de la cantidad mParaGanar para poder deducir que en esta fila n hay un gane posible.

De ser asi, se llama a la funcion auxiliar determinarFichaParaGanarHorizontal, que determinara cual es la ficha faltante en esa fila n, la cual
sera la ficha que permitira a la maquina o al usuario ganar la partida. En caso de que la cantidad de fichas presentes en esa fila n no este a
una unidad indica dos posibles situaciones: el jugador contrario ya tiene fichas en esa fila, o falta mas de un espacio vacio que rellenar
con fichas propias para poder generar una linea valida. En este ultimo escenario, se retorna una lista nula como representacion de que no
existe una solucion valida para esta fila n especifica.

En caso de que la lista de fichas colocadas no sea nula, quiere decir que dentro de la misma pueden haber fichas que posibiliten una linea
ganadora, por lo que se procede a comparar si el caar (el primer elemento del primer elemento) de las fichas colocadas (numero que indica la
fila n) sea igual a el car (primer elemento) de la ficha analizar. Esto significaria que la fila de la ficha por analizar es la misma de la
fila de la ficha actual dentro de la lista. Debido a esto, se llama de forma recursiva a la funcion, recortando la lista de fichas colocadas,
y agregando el cdar (el ultimo elemento de la tupla, del primer elemento) de las fichas colocadas. Esta actualizacion de presentes quiere decir
que, dentro de esa fila n, hay una nueva posicion m que si tiene una ficha colocada.

En caso de que no sea igual, simplemente se recorta la lista de las fichas colocadas dentro de la llamada recursiva.
|#
(define (fichaParaGanarHorizontal fichasMaquina fichaAnalizar mParaGanar presentes candidatos)
  (if (null? fichasMaquina)
      (if (= (+ (length presentes) 1) mParaGanar)
          (determinarFichaParaGanarHorizontal presentes fichaAnalizar 1 candidatos)
          '()
      )
      (if (= (caar fichasMaquina) (car fichaAnalizar))
          (fichaParaGanarHorizontal (cdr fichasMaquina)
                                    fichaAnalizar
                                    mParaGanar
                                    (append presentes (cdar fichasMaquina))
                                    candidatos
          )
          (fichaParaGanarHorizontal (cdr fichasMaquina)
                                     fichaAnalizar
                                     mParaGanar
                                     presentes
                                     candidatos
          )
      )
  )
)
#|
Funcion final dentro de la validacion de los ganes horizontales. El programa llega a esta funcion solo si de antemano se ha determinado que
la cantidad de fichas de un mismo jugador dentro de una fila esta a una unidad de la cantidad necesaria para ganar, dada por la dimension m
de la matriz. Recibe como parametros la lista de posiciones m donde hay fichas, la ficha en cuestion que esta siendo analizada, y un contador
que sirve de parametro auxiliar recursivo. Finalmente, recibe la lista de candidatos para verificar si se puede colocar una ficha en el
lugar indicado dentro de la matriz

Si la cantidad de posiciones presentes es nula, quiere decir que se ha llegado al final de posibles posiciones a analizar dentro de la fila,
por lo que se retorna entonces la posicion de la ficha ganadora como (posicion n de la ficha a analizar, contador), representando que la unica
posicion valida seria la ultima de la fila, la que tenga un valor de columna m.

En caso de que aun queden elementos en la lista de posiciones presentes, se verifica si el contador es igual al primer elemento de esta lista.
De ser asi, quiere decir que la posicion m ausente no es la actual, ya que el contador es una forma de preguntarle al programa si un valor, que
empieza en 1 y termina en m, esta dentro de lista de posiciones posibles que ya tienen una ficha del jugador. Debido a esto, se sabe
que la posicion ganadora, ausente de ficha, no es la que se encuentra en la iteracion actual, por lo que se procede a la siguiente llamada,
recortando la lista de presentes, y aumentando en 1 el contador.

Si el contador no es igual al primer elemento, se puede decir que entonces el contador es de hecho la posicion m donde se tiene que colocar
la ficha dentro de una determinada fila n, ya que el contador crece de forma sincronica conforme se compara el primer elemento de la lista
ordenada de posibles m's. En el momento en que se llegue a una discrepancia entre contador y primer elemento de la lista de presentes (que esta
ordenada de menor a mayor, al ser rellenada de forma paulatina por el recorrido de la matriz) se retorna el valor de (posicion n de la ficha
a analizar, contador).

Es importante recalcar que la colocacion de fichas solo ocurre si la posicion dada por (fichaAnalizar, contador) esta dentro de la lista
candidatos, por lo que antes de cada colocacion de fichas, se llama a la funcion revisarCandidatos para determinar si se coloca o no la ficha.
|#
(define (determinarFichaParaGanarHorizontal presentes fichaAnalizar contador candidatos)
  (if (null? presentes)
      (if (revisarCandidatos candidatos (append (list (car fichaAnalizar)) (list contador)))
          (append (list (car fichaAnalizar)) (list contador))
          '()
      )

      (if (= contador (car presentes))
          (determinarFichaParaGanarHorizontal (cdr presentes)
                                              fichaAnalizar
                                              (+ contador 1)
                                              candidatos
          )
          (if (revisarCandidatos candidatos (append (list (car fichaAnalizar)) (list contador)))
              (append (list (car fichaAnalizar)) (list contador))
              '()
          )
      )
  ) 
)
#|
Funcion que tiene un comportamiento similar a la de revisarGaneHorizontal. Recibe como parametros las dos listas de fichas colocadas por el
usuario o por la maquina, ademas de la cantidad necesaria de fichas colocadas en una misma columna m, llamada nParaGanar, y determinada por la
dimension n de la matriz. La lista de candidatos cumple la misma funcion que en la definicion anterior. De igual manera que la validacion
horizontal, son tres funciones las que componen esta parte del codigo.
Primeramente, se recorre la lista de fichasMaquinaAuxiliar, y en cada iteracion, hasta que la misma este vacia (es decir, que sea nula), se
trata de encontrar una nueva ficha para ganar por medio de la funcion fichaParaGanarVertical.
|#
(define (revisarGaneVertical fichasMaquina fichasMaquinaAuxiliar nParaGanar fichaParaGanar candidatos)
  (if (null? fichasMaquinaAuxiliar)
      fichaParaGanar
      (if (null? fichaParaGanar)
          (revisarGaneVertical fichasMaquina
                               (cdr fichasMaquinaAuxiliar)
                               nParaGanar
                               (fichaParaGanarVertical fichasMaquina (car fichasMaquinaAuxiliar) nParaGanar '() candidatos)
                               candidatos
          )
          fichaParaGanar
      )
  )
)
#|
Por cada ficha colocada por el usuario o por la maquina, se intenta encontrar una ficha que permita el gane por medio de esta funcion. Recibe
como parametro a las fichas colocadas por el usuario o por la maquina, la ficha especifica a analizar en la iteracion actual, la dimension
que debe tener la linea para ganar, dada por nParaGanar, una lista presentes que sirve de auxiliar dentro de la recursividad, y la lista de
candidatos donde, de poder formar una linea, el sistema podria o no colocar una ficha.

Esta funcion se recorre de manera recursiva hasta que la lista de fichas del jugador sea vacia, en este momento se valida si la cantidad
de fichas presentes en una determinada columna m esta a una unidad de la cantidad necesaria, lo cual indicaria que solo falta una ficha
para ganar en dicha columna m. De cumplirse lo anterior, se ejecuta la funcion determinarFichaParaGanarVertical, que encontrara la ficha
que el jugador debe colocar para ganar.

Si la lista de fichas del jugador no es vacia, se seguiran comparando sus valores m con el de la iteracion actual, con el fin de verificar
cuantas fichas hay presentes dentro de una columna, y poder decidir si se puede determinar una ficha que permita el gane.
|#
(define (fichaParaGanarVertical fichasMaquina fichaAnalizar nParaGanar presentes candidatos)
  (if (null? fichasMaquina)
      (if (= (+ (length presentes) 1) nParaGanar)
          (determinarFichaParaGanarVertical presentes fichaAnalizar 1 candidatos)
          '()
      )
      (if (= (length fichasMaquina) 1)
          (if (= (cadar fichasMaquina) (cadr fichaAnalizar))
              (fichaParaGanarVertical (cdr fichasMaquina)
                                        fichaAnalizar
                                        nParaGanar
                                        (append presentes (list (caar fichasMaquina)))
                                        candidatos
              )
              (fichaParaGanarVertical (cdr fichasMaquina)
                                        fichaAnalizar
                                        nParaGanar
                                        presentes
                                        candidatos
              )
          )
                                        
          (if (= (cadar fichasMaquina) (cadr fichaAnalizar))
              (fichaParaGanarVertical (cdr fichasMaquina)
                                        fichaAnalizar
                                        nParaGanar
                                        (append presentes (list (caar fichasMaquina)))
                                        candidatos
              )
              (fichaParaGanarVertical (cdr fichasMaquina)
                                        fichaAnalizar 
                                        nParaGanar
                                        presentes
                                        candidatos
              )
          )
      )
  )
)
#|
Funcion utilizada para determinar con cual ficha el usuario o la maquina pueden ganar con una linea vertical. Si el sistema ingresa aqui,
significa que, o usuario o maquina, estan a una ficha de ganar en alguna de las columnas, pero no necesariamente pueden colocar una ficha
en esa posicion. Para eso justamente es que funciona el parametro de candidatos, que contiene todas las posiciones vacias dentro de la matriz,
y hace posible la colocacion de fichas si la posicion deseada esta contendida en dicha lista.

El funcionamiento es el mismo que el de determinarFichaParaGanarHorizontal, variando solo la forma de retornar el resultado, refiriendose a
una posicion (m n), debido a que la linea que se quiere formar es vertical.
|#
(define (determinarFichaParaGanarVertical presentes fichaAnalizar contador candidatos)
  (if (null? presentes)
      (if (revisarCandidatos candidatos (append (list contador) (list (cadr fichaAnalizar))))
          (append (list contador) (list (cadr fichaAnalizar)))
          '()
      )
      (if (= contador (car presentes))
          (determinarFichaParaGanarVertical (cdr presentes)
                                              fichaAnalizar
                                              (+ contador 1)
                                              candidatos
          )
          (if (revisarCandidatos candidatos (append (list contador) (list (cadr fichaAnalizar))))
              (append (list contador) (list (cadr fichaAnalizar)))
              '()
          )
      )
  ) 
)

;=======================================================================================================================


(define (diagonalesValidas matriz)
  (append (diagonalesDescendentesVerticales (length (car matriz)) (length matriz) 1 (length matriz) (length matriz) '() '())
          (diagonalesDescendentesHorizontales (length (car matriz)) (length matriz) 2 1 2 '() '())
          (descartarDiagonales (diagonalesAscendentesVerticales (length (car matriz)) (length matriz) (length (car matriz)) (length matriz) (length matriz) '() '()) '())
          (descartarDiagonales (diagonalesAscendentesHorizontales (length (car matriz)) (length matriz) (- (length (car matriz)) 1) 1 (- (length (car matriz)) 1) '() '()) '())
  )           
)

    
(define (diagonalesAscendentesVerticales mMax nMax mActual nActual nInicio diagonalActual diagonales)
  (if (= nInicio 0)
      diagonales
      (if (= nActual nMax)
          (diagonalesAscendentesVerticales mMax
                                           nMax
                                           mMax
                                           (- nInicio 1)
                                           (- nInicio 1)
                                           '()
                                           (append diagonales (list (append diagonalActual (list (append (list nActual) (list mActual)))))))
          (if (= mActual 1)
              (diagonalesAscendentesVerticales mMax
                                               nMax
                                               mMax
                                               (- nInicio 1)
                                               (- nInicio 1)
                                               '()
                                               (append diagonales (list (append diagonalActual (list (append (list nActual) (list mActual)))))))
              (diagonalesAscendentesVerticales mMax
                                               nMax
                                               (- mActual 1)
                                               (+ nActual 1)
                                               nInicio
                                               (append diagonalActual (list (append (list nActual) (list mActual))))
                                                diagonales)))))



(define (diagonalesAscendentesHorizontales mMax nMax mActual nActual mInicio diagonalActual diagonales)
  (if (= mInicio 0)
      diagonales
      (if (= nActual nMax)
          (diagonalesAscendentesHorizontales mMax
                                             nMax
                                             (- mInicio 1)
                                             1
                                             (- mInicio 1)
                                             '()
                                             (append diagonales (list (append diagonalActual (list (append (list nActual) (list mActual)))))))
          (if (= mActual 1)
              (diagonalesAscendentesHorizontales mMax
                                                 nMax
                                                 (- mInicio 1)
                                                 1
                                                 (- mInicio 1)
                                                 '()
                                                 (append diagonales (list (append diagonalActual (list (append (list nActual) (list mActual)))))))
              (diagonalesAscendentesHorizontales mMax
                                                 nMax
                                                 (- mActual 1)
                                                 (+ nActual 1)
                                                 mInicio
                                                 (append diagonalActual (list (append (list nActual) (list mActual))))
                                                 diagonales)))))
                                               
                                                 
                                                   
              
                                               
                                           
(define (diagonalesDescendentesVerticales mMax nMax mActual nActual nInicio diagonalActual diagonales)
  (if (= nInicio 0)
      diagonales
      (if (= (- nActual 1) nMax)
          (if (> (length diagonalActual) 2)
              (diagonalesDescendentesVerticales mMax
                                                nMax
                                                1
                                                (- nInicio 1)
                                                (- nInicio 1)
                                                '()
                                                (append diagonales (list diagonalActual))
              )
              (diagonalesDescendentesVerticales mMax
                                                nMax
                                                1
                                                (- nInicio 1)
                                                (- nInicio 1)
                                                '()
                                                diagonales
              )
          )
          (if (<= mActual mMax)    
              (diagonalesDescendentesVerticales mMax
                                                nMax
                                                (+ mActual 1)
                                                (+ nActual 1)
                                                nInicio
                                                (append diagonalActual (list (append (list nActual) (list mActual))))
                                                diagonales
              )
              (diagonalesDescendentesVerticales mMax
                                                nMax
                                                (+ mActual 1)
                                                (+ nActual 1)
                                                nInicio
                                                diagonalActual
                                                diagonales
              )
          )       
      )      
  )
)


(define (diagonalesDescendentesHorizontales mMax nMax mActual nActual mInicio diagonalActual diagonales)
  (if (> mInicio mMax)
      diagonales
      (if (> nActual nMax)
          (if (> (length diagonalActual) 2)
              (diagonalesDescendentesHorizontales mMax
                                                  nMax
                                                  (+ mInicio 1)
                                                  1
                                                  (+ mInicio 1)
                                                  '()
                                                  (append diagonales (list diagonalActual))
              )
              (diagonalesDescendentesHorizontales mMax
                                                  nMax
                                                  (+ mInicio 1)
                                                  1
                                                  (+ mInicio 1)
                                                  '()
                                                  diagonales
               )
          )
          (if (> mActual mMax)
              (if (> (length diagonalActual) 2)
                  (diagonalesDescendentesHorizontales mMax
                                                      nMax
                                                      (+ mInicio 1)
                                                      1
                                                      (+ mInicio 1)
                                                      '()
                                                      (append diagonales (list diagonalActual))
                  )
                  (diagonalesDescendentesHorizontales mMax
                                                      nMax
                                                      (+ mInicio 1)
                                                      1
                                                      (+ mInicio 1)
                                                      '()
                                                      diagonales
                  )
              )
              (diagonalesDescendentesHorizontales mMax
                                                  nMax
                                                  (+ mActual 1)
                                                  (+ nActual 1)
                                                  mInicio
                                                  (append diagonalActual (list (append (list nActual) (list mActual))))
                                                  diagonales
              )
          )
      )
  )
)
                                                  
          



(define (descartarDiagonales diagonales diagonalesValidos)
  (if (null? diagonales)
      diagonalesValidos
      (if (>= (length (car diagonales)) 3)
          (descartarDiagonales (cdr diagonales) (append diagonalesValidos (list (car diagonales))))
          (descartarDiagonales (cdr diagonales) diagonalesValidos))))

                  







(define (revisarGaneDiagonal matriz diagonales fichaGanar usuario)
  (if (null? diagonales)
      fichaGanar
      (if (null? fichaGanar)
          (revisarGaneDiagonal matriz
                               (cdr diagonales)
                               (analizarDiagonal matriz usuario (car diagonales) (car diagonales) 0)
                               usuario)
          fichaGanar)))

(define (analizarDiagonal matriz usuario diagonal diagonalAuxiliar cantidad)
  (if (null? diagonal)
      (if (= (+ cantidad 1) (length diagonalAuxiliar))
          (determinarFichaGaneDiagonal matriz diagonalAuxiliar)
          '())
      (analizarDiagonal matriz
                        usuario
                        (cdr diagonal)
                        diagonalAuxiliar
                        (+ cantidad (analizarPosicionDiagonal matriz usuario (car diagonal))))))


(define (analizarPosicionDiagonal matriz usuario posicion)
  (if (= (encontrarFichaPorPosicion matriz (car posicion) (cadr posicion) '()) usuario)
      1
      0))
  
  
(define (determinarFichaGaneDiagonal matriz diagonal)
  (if (null? diagonal)
      '()
      (if (analizarPosicionVaciaDiagonal matriz (car diagonal))
          (car diagonal)
          (determinarFichaGaneDiagonal matriz (cdr diagonal)))))
      
   
(define (analizarPosicionVaciaDiagonal matriz posicion)
  (if (= (encontrarFichaPorPosicion matriz (car posicion) (cadr posicion) '()) 0)
      #t
      #f))
  

  
  
;=======================================================================================================================
#|
Funcion utilizada para revisar la lista de candidatos y determinar si una posicion es valida para colocar una ficha en la matriz. Recibe como
parametros a la lista de candidatos y a la posicion donde se quiere colocar la ficha.
En caso de que la lista de candidatos sea nula, quiere decir que no se encontro antes a la posicion dentro de la lista de candidatos, por lo
que se define como nula la colocacion de dicha fila, y se retorna un false.

En caso de que la lista de candidatos no sea vacia, se comparan las posiciones de la tupla de la primera posicion de candidatos con las
posiciones de la tupla posicion, y si ambas coinciden, se dice que la ficha va a ser colocada en un candidato correcto, que corresponde a un
espacio vacio dentro de la matriz.

Si alguna de las posiciones de la tupla de la primera posicion de candidatos es diferente que las posiciones de la tupla posicion, se retorna
la funcion de manera recursiva, recortando la lista de candidatos, ya que la ficha no pretende ser colocada en dicha primera posicion de
candidatos.
|#
(define (revisarCandidatos candidatos posicion)
  (if (null? candidatos)
      #f
      (if (= (caar candidatos) (car posicion))
          (if (= (cadar candidatos) (cadr posicion))
              #t
              (revisarCandidatos (cdr candidatos) posicion)
          )
          (revisarCandidatos (cdr candidatos) posicion)
       )
  )
)       
;----------------------------------------------------------ALGORITMO VORAZ---------------------------------------------------------------------
#|
Funcion que inicia la ejecucion del algoritmo voraz. Es llamada cada vez que la maquina tiene que colocar una ficha, y por medio de las
diversas subfunciones, se determina cual seria la posicion idonea para colocar la ficha, en funcion de las fichas propias de la maquina, y las
colocadas por el usuario. Recibe como parametro a la matriz de juego.
|#
(define (ejecutarAlgoritmoVoraz matriz)
  (display "Ejecutando el algoritmo voraz \n")
  (display matriz)
  (display "\n")
  (funcionDeViabilidad matriz
                      (encontrarConjuntoDeCandidatos matriz)
                      (encontrarFichasColocadas matriz '() 0 1 1 '())
                      (encontrarFichasColocadas matriz '() 0 1 2 '())
  )
)
#|
Primera parte del algoritmo voraz. Este funcion se encarga de encontrar el conjunto de candidatos posibles que pueden contribuir a la solucion,
es decir, las posiciones que pueden ser ocupadas por la nueva ficha a colocar por la maquina. Recibe como parametro a la matriz de juego, y
llama a la funcion explicada anteriormente encontrarFichasColocadas, que retorna una lista con todas las posiciones con elemento 0 (vacias)
dentro de la matriz.
|#
(define (encontrarConjuntoDeCandidatos matriz)
  (encontrarFichasColocadas matriz '() 0 1 0 '())
)

#|
Segunda parte del algoritmo voraz. Esta funcion se encarga de determinar la viabilidad del conjunto de candidatos. Recibe como parametros
a la matriz, la lista de posibles candidatos, las fichas colocadas por el jugador, y las fichas colocadas por la maquina.
|#
(define (funcionDeViabilidad matriz candidatosParaColocar fichasJugador fichasMaquina)

  ;Maquina revisa si puede ganar de forma horizontal
  (if (not (null? (revisarGaneHorizontal fichasMaquina fichasMaquina (length (car matriz)) '() candidatosParaColocar)))
      (append (list (append (list (car (revisarGaneHorizontal fichasMaquina fichasMaquina (length (car matriz)) '() candidatosParaColocar)))
                            (list (cadr (revisarGaneHorizontal fichasMaquina fichasMaquina (length (car matriz)) '() candidatosParaColocar)))
                            )
                    )
      (list (colocarFichaJugador (car (revisarGaneHorizontal fichasMaquina fichasMaquina (length (car matriz)) '() candidatosParaColocar))
                           (cadr (revisarGaneHorizontal fichasMaquina fichasMaquina (length (car matriz)) '() candidatosParaColocar))
                           1
                           (length matriz)
                           matriz
                           '()
                           2
      ))
      )
      ;Maquina revisa si puede ganar de forma vertical
      (if (not (null? (revisarGaneVertical fichasMaquina fichasMaquina (length matriz) '() candidatosParaColocar)))
          (append (list (append (list (car (revisarGaneVertical fichasMaquina fichasMaquina (length matriz) '() candidatosParaColocar)))
                                (list (cadr (revisarGaneVertical fichasMaquina fichasMaquina (length matriz) '() candidatosParaColocar)))
                                )
                        )
          (list (colocarFichaJugador (car (revisarGaneVertical fichasMaquina fichasMaquina (length matriz) '() candidatosParaColocar))
                               (cadr (revisarGaneVertical fichasMaquina fichasMaquina (length matriz) '() candidatosParaColocar))
                               1
                               (length matriz)
                               matriz
                               '()
                               2 
          ))
          )
          ;Maquina revisa si puede ganar de forma diagonal
          (if (not (null? (revisarGaneDiagonal matriz (diagonalesValidas matriz) '() 2)))
              (append (list (append (list (car (revisarGaneDiagonal matriz (diagonalesValidas matriz) '() 2)))
                                    (list (cadr (revisarGaneDiagonal matriz (diagonalesValidas matriz) '() 2)))
                                    )
                            )
              (list (colocarFichaJugador (car (revisarGaneDiagonal matriz (diagonalesValidas matriz) '() 2))
                                   (cadr (revisarGaneDiagonal matriz (diagonalesValidas matriz) '() 2))
                                   1
                                   (length matriz)
                                   matriz
                                   '()
                                   2
              ))
              )
              ;Maquina revisa si puede perder de forma horizontal
              (if (not (null? (revisarGaneHorizontal fichasJugador fichasJugador (length (car matriz)) '() candidatosParaColocar)))
                  (append (list (append (list (car (revisarGaneHorizontal fichasJugador fichasJugador (length (car matriz)) '() candidatosParaColocar)))
                                        (list (cadr (revisarGaneHorizontal fichasJugador fichasJugador (length (car matriz)) '() candidatosParaColocar)))
                                        )
                                )
                  (list (colocarFichaJugador (car (revisarGaneHorizontal fichasJugador fichasJugador (length (car matriz)) '() candidatosParaColocar))
                                       (cadr (revisarGaneHorizontal fichasJugador fichasJugador (length (car matriz)) '() candidatosParaColocar))
                                       1
                                       (length matriz)
                                       matriz
                                       '()
                                       2
                  ))
                  )
                  ;Maquina revisa si puede perder de forma vertical
                  (if (not (null? (revisarGaneVertical fichasJugador fichasJugador (length matriz) '() candidatosParaColocar)))
                      (append (list (append (list (car (revisarGaneVertical fichasJugador fichasJugador (length matriz) '() candidatosParaColocar)))
                                            (list (cadr (revisarGaneVertical fichasJugador fichasJugador (length matriz) '() candidatosParaColocar)))
                                            )
                                    )
                      (list (colocarFichaJugador (car (revisarGaneVertical fichasJugador fichasJugador (length matriz) '() candidatosParaColocar))
                                           (cadr (revisarGaneVertical fichasJugador fichasJugador (length matriz) '() candidatosParaColocar))
                                           1
                                           (length matriz)
                                           matriz
                                           '()
                                           2
                      ))
                      )
                      ;Maquina revisa si puede perder de forma diagonal
                      (if (not (null? (revisarGaneDiagonal matriz (diagonalesValidas matriz) '() 1)))
                          (append (list (append (list (car (revisarGaneDiagonal matriz (diagonalesValidas matriz) '() 1)))
                                                (list (cadr (revisarGaneDiagonal matriz (diagonalesValidas matriz) '() 1)))
                                                )
                                        )
                          (list (colocarFichaJugador (car (revisarGaneDiagonal matriz (diagonalesValidas matriz) '() 1))
                                   (cadr (revisarGaneDiagonal matriz (diagonalesValidas matriz) '() 1))
                                   1
                                   (length matriz)
                                   matriz
                                   '()
                                   2
                          ))
                          )
                          (append (list (append (list 0) (list 0))) (list matriz))
                      )
                  )
              )           
          )
      )
  )
)
  
 





(define (hayGanador matriz fichasJugador fichasMaquina jugadorActual)
  (if (= jugadorActual 1)
      (encontrarFichasColocadas matriz '() 0 1 1 '())
      (encontrarFichasColocadas matriz '() 0 1 2 '())
  )   
)

    
(TTT 3 3)